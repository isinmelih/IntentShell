from enum import Enum
from typing import List, Optional
from pydantic import BaseModel, Field, field_validator

class RiskLevel(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    VERY_HIGH = "very_high"

class RiskAssessment(BaseModel):
    level: RiskLevel
    reasons: List[str]
    score: int = 0

class Intent(BaseModel):
    intent_type: str = Field(..., description="The type of intent, e.g., 'delete_files', 'git_log'")
    action: Optional[str] = Field(None, description="The action to perform: list, move, delete, etc.")
    target: str = Field(..., description="Target file, directory, or system resource")
    filters: List[str] = Field(default_factory=list, description="File extensions or patterns to filter")
    recursive: bool = Field(default=False, description="Whether to apply recursively")
    destination: Optional[str] = Field(None, description="Destination path for move/copy operations")
    content: Optional[str] = Field(None, description="Generated content to be written to a file")
    generated_command: Optional[str] = Field(None, description="PowerShell command generated by LLM for fallback intents")
    risk: RiskLevel = Field(..., description="Assessed risk level")
    description: str = Field(..., description="Human readable description of the intent")
    
    # Enhanced Fields for Phase 8
    requires_elevation: bool = Field(default=False, description="Whether the command requires admin privileges")
    confirm_level: str = Field(default="enter", description="Confirmation type: none, enter, type_yes, two_step")
    dry_run_safe: bool = Field(default=True, description="Whether dry-run is safe to execute")
    potential_slow: bool = Field(default=False, description="Whether the operation might be slow")
    needs_external_tool: List[str] = Field(default_factory=list, description="List of external tools required (e.g. ffmpeg)")
    protocol_version: str = Field(default="intent-v1", description="Protocol version for the Kernel Bridge")

    @field_validator('generated_command')
    def validate_command_safety(cls, v):
        if v:
            import re
            
            # ALLOW Add-Type ONLY IF it is loading standard Windows Forms for UI interactions
            # This is required for the Timer feature (MessageBox)
            # We use a negative lookahead to ensure we are only blocking potentially malicious uses,
            # or we explicitly allow the specific AssemblyName pattern used in our Timer.
            
            # Regex Explanation:
            # Block Add-Type UNLESS it is followed by 'System.Windows.Forms', 'System.Drawing' or 'System.Speech'
            if re.search(r"\bAdd-Type\b(?!\s+-AssemblyName\s+(?:System\.Windows\.Forms|System\.Drawing|System\.Speech))", v, re.IGNORECASE):
                 raise ValueError("Security Alert: Dynamic code compilation detected (Add-Type blocked unless for UI/Audio).")

            # Block other reflection methods
            if re.search(r"\b(Reflection\.Assembly|Emit)\b", v, re.IGNORECASE):
                raise ValueError("Security Alert: Reflection/Emit is prohibited.")
                
            # Block Invoke-Expression aliases
            # ALLOW Invoke-Expression ONLY IF it is used safely inside a Start-Job scriptblock wrapper for background tasks
            # This is required for the Timer feature which runs a scriptblock in a job
            
            if re.search(r"\b(iex|Invoke-Expression)\b", v, re.IGNORECASE):
                # If it's part of the standard Start-Job wrapper we use in IntentResolver, allow it
                # The pattern we use is: Start-Job -ScriptBlock { param($script); Invoke-Expression $script }
                if "Start-Job" in v and "param($script); Invoke-Expression $script" in v:
                    pass # Allow this specific safe pattern
                else:
                    raise ValueError("Security Alert: Invoke-Expression is prohibited.")
        return v
